akka {

  loggers = ["akka.event.slf4j.Slf4jLogger"]
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
  loglevel = INFO

  actor {
    provider = cluster


    # Only for convenience in the quickstart, java serialization should not be used for actual applications
    warn-about-java-serializer-usage = off
  }

  remote.netty.tcp.port=0
  remote.netty.tcp.hostname=127.0.0.1

  cluster {
    seed-nodes = [
      "akka.tcp://ClusterSystem@127.0.0.1:2551",
      "akka.tcp://ClusterSystem@127.0.0.1:2552"]

    # Only for convenience in the quickstart, auto-downing should not be used for actual applications.
    # Read more here: http://doc.akka.io/docs/akka/current/scala/cluster-usage.html#auto-downing-do-not-use-
    auto-down-unreachable-after = 10s

    # Needed when running many actor systems in the same JVM
    jmx.multi-mbeans-in-same-jvm = on
  }

  # Only for convenience in the quickstart, do not use leveldb or the disk snapshot store for actual applications
  persistence {
    journal.plugin = "cassandra-journal"
    snapshot-store.plugin = "cassandra-snapshot-store"
  }

  # Run the pubsub mediator on all nodes
  extensions = ["akka.cluster.pubsub.DistributedPubSub"]
}

# Configuration related to the app is in its own namespace
distributed-workers {
  # Each worker pings the master with this interval
  # to let it know that it is alive
  worker-registration-interval = 10s
  # If a worker hasn't gotten in touch in this long
  # it is removed from the set of workers
  consider-worker-dead-after = 60s

  # If a workload hasn't finished in this long it
  # is considered failed and is retried
  work-timeout = 10s

}